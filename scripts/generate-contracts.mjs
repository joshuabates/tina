import fs from "node:fs";
import path from "node:path";

const root = process.cwd();
const contractPath = path.join(root, "contracts", "orchestration-core.contract.json");

/** @typedef {{name: string, rust: string, kind: "string" | "number" | "id" | "boolean", optional?: boolean, table?: string}} Field */

/** @type {{orchestrationCore: Field[]}} */
const contract = JSON.parse(fs.readFileSync(contractPath, "utf8"));
const fields = contract.orchestrationCore;

const generatedHeader =
  "// This file is generated by scripts/generate-contracts.mjs.\n" +
  "// Do not edit by hand.";

function convexValueExpr(field) {
  let base;
  if (field.kind === "string") {
    base = "v.string()";
  } else if (field.kind === "number") {
    base = "v.number()";
  } else if (field.kind === "boolean") {
    base = "v.boolean()";
  } else if (field.kind === "id") {
    const table = field.table;
    if (!table) {
      throw new Error(`Field ${field.name} with kind=id must define table`);
    }
    base = `v.id(\"${table}\")`;
  } else {
    throw new Error(`Unsupported kind ${field.kind} for ${field.name}`);
  }

  return field.optional ? `v.optional(${base})` : base;
}

function webSchemaExpr(field) {
  if (field.kind === "boolean") {
    return field.optional ? "optionalBoolean" : "Schema.Boolean";
  }
  const base = field.kind === "number" ? "Schema.Number" : "Schema.String";
  if (!field.optional) {
    return base;
  }
  return field.kind === "number" ? "optionalNumber" : "optionalString";
}

function rustTypeExpr(field) {
  let base;
  if (field.kind === "number") base = "f64";
  else if (field.kind === "boolean") base = "bool";
  else base = "String";
  return field.optional ? `Option<${base}>` : base;
}

const convexLines = [
  generatedHeader,
  "",
  'import { v } from "convex/values";',
  "",
  "export const orchestrationCoreTableFields = {",
  ...fields.map((f) => `  ${f.name}: ${convexValueExpr(f)},`),
  "} as const;",
  "",
];

fs.writeFileSync(
  path.join(root, "convex", "generated", "orchestrationCore.ts"),
  convexLines.join("\n"),
);

const webLines = [
  generatedHeader,
  "",
  'import { Schema } from "effect";',
  "",
  "const optionalString = Schema.optionalWith(Schema.String, { as: \"Option\" });",
  "const optionalNumber = Schema.optionalWith(Schema.Number, { as: \"Option\" });",
  "const optionalBoolean = Schema.optionalWith(Schema.Boolean, { as: \"Option\" });",
  "",
  "export const orchestrationCoreFields = {",
  ...fields.map((f) => `  ${f.name}: ${webSchemaExpr(f)},`),
  "} as const;",
  "",
];

fs.writeFileSync(
  path.join(root, "tina-web", "src", "schemas", "generated", "orchestrationCore.ts"),
  webLines.join("\n"),
);

const rustLines = [
  generatedHeader,
  "",
  "use serde::{Deserialize, Serialize};",
  "",
  "#[derive(Debug, Clone, Serialize, Deserialize)]",
  "pub struct OrchestrationRecord {",
  "    pub project_id: Option<String>,",
  "    pub design_id: Option<String>,",
  ...fields.map((f) => `    pub ${f.rust}: ${rustTypeExpr(f)},`),
  "}",
  "",
];

fs.writeFileSync(
  path.join(root, "tina-data", "src", "generated", "orchestration_core_fields.rs"),
  rustLines.join("\n"),
);

console.log("Generated orchestration contract artifacts:");
console.log("- convex/generated/orchestrationCore.ts");
console.log("- tina-web/src/schemas/generated/orchestrationCore.ts");
console.log("- tina-data/src/generated/orchestration_core_fields.rs");
